######################################################################
##                   Michel Bermond, 19/09/2025                     ##
##                       APST2607 reserved                          ##
######################################################################

######################################################################
##                          MODULE main.py                          ##
##                            Description                           ##
##        this program compare  a archive with a reference          ##
##          files and report any missing or extra files.            ##
######################################################################

#### import
import os
import tkinter as tk
from tkinter import filedialog, scrolledtext, messagebox, ttk, simpledialog
import json
import datetime
import hashlib


#### GUI Class
class ArchiveComparerGUI:
    def __init__(self, root):
        """
        Initialize the GUI for the Archive Comparer application.
        """
        self.root = root
        self.root.title("Comparateur d'Archives - APST2607")
        self.root.geometry("1000x700")
        self.root.resizable(True, True)
        
        # Configure modern styling
        self.setup_styles()
        
        # Set modern color scheme
        self.colors = {
            'primary': '#2E86AB',      # Professional blue
            'secondary': '#A23B72',    # Accent purple
            'success': '#F18F01',      # Orange for success
            'danger': '#C73E1D',       # Red for errors
            'background': '#F5F7FA',   # Light gray background
            'surface': '#FFFFFF',      # White surface
            'text_primary': '#2D3748', # Dark gray text
            'text_secondary': '#718096', # Light gray text
            'border': '#E2E8F0'        # Light border
        }
        
        # Configure root window
        self.root.configure(bg=self.colors['background'])
        
        # Current comparison result
        self.current_report = None
        
        # Large console window reference
        self.large_console_window = None
        self.large_console_text = None
        
        # Setup the beautiful GUI
        self.setup_gui()
    
    def setup_styles(self):
        """
        Configure modern ttk styles for the application.
        """
        style = ttk.Style()
        
        # Configure modern button style
        style.configure('Modern.TButton',
                       padding=(20, 10),
                       font=('Segoe UI', 9, 'bold'))
        
        # Configure special compare button style with visible colors
        style.configure('Compare.TButton',
                       padding=(20, 10),
                       font=('Segoe UI', 9, 'bold'),
                       relief='raised',
                       borderwidth=2)
        
        # Map states for compare button to ensure visibility
        style.map('Compare.TButton',
                 relief=[('pressed', 'sunken')],
                 borderwidth=[('pressed', 2)])
        
        # Try alternative approach - configure with theme colors
        try:
            style.theme_use('clam')  # Use clam theme for better color support
        except:
            pass  # If clam theme not available, continue with default
        
        # Configure entry style
        style.configure('Modern.TEntry',
                       padding=(10, 8),
                       font=('Segoe UI', 9))
        
        # Configure label style
        style.configure('Title.TLabel',
                       font=('Segoe UI', 12, 'bold'),
                       foreground='#2D3748')
        
        style.configure('Subtitle.TLabel',
                       font=('Segoe UI', 10),
                       foreground='#4A5568')
        
        style.configure('Header.TLabel',
                       font=('Segoe UI', 14, 'bold'),
                       foreground='#1A202C')
        
        # Configure frame styles
        style.configure('Card.TFrame',
                       relief='flat',
                       borderwidth=1)
        
        style.configure('Header.TFrame',
                       relief='flat',
                       borderwidth=0)
    
    def setup_gui(self):
        """
        Create and arrange all beautiful GUI components.
        """
        # Main container with padding
        main_container = ttk.Frame(self.root, style='Header.TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights for resizing
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(3, weight=1)
        
        # Header Section
        self.create_header(main_container)
        
        # Input Section
        self.create_input_section(main_container)
        
        # Action Buttons Section
        self.create_action_section(main_container)
        
        # Results Console Section
        self.create_console_section(main_container)
        
        # Status Bar
        self.create_status_bar(main_container)
        
    def create_action_section(self, parent):
        """
        Create a beautiful action buttons section.
        """
        action_frame = ttk.LabelFrame(parent, text=" ‚ö° Actions ", 
                                    padding="20", style='Card.TFrame')
        action_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        
        # Create the primary compare button with custom styling
        compare_btn = tk.Button(
            action_frame,
            text="üîç Comparer les Archives",
            command=self.compare_archives_gui,
            font=('Segoe UI', 9, 'bold'),
            bg='#2E86AB',          # Blue background
            fg='white',            # White text
            activebackground='#1E5B7A',  # Darker blue when pressed
            activeforeground='white',     # White text when pressed
            relief='flat',
            borderwidth=0,
            padx=20,
            pady=10,
            cursor='hand2'
        )
        compare_btn.grid(row=0, column=0, padx=10, pady=5, sticky=(tk.W, tk.E))
        
        # Create other buttons with ttk
        other_buttons = [
            ("üì§ Exporter R√©sultat", self.export_result, 0, 1),
            ("üì• Importer R√©sultat", self.import_result, 0, 2),
            ("üóëÔ∏è Vider Console", self.clear_console, 0, 3),
            ("üñ•Ô∏è Grande Console", self.open_large_console, 1, 0),
            ("üîç D√©tecter Doublons", self.detect_duplicates, 1, 1)
        ]
        
        for text, command, row, col in other_buttons:
            btn = ttk.Button(action_frame, text=text, command=command, style='Modern.TButton')
            btn.grid(row=row, column=col, padx=10, pady=5, sticky=(tk.W, tk.E))
        
        # Configure column weights for equal distribution
        for i in range(4):
            action_frame.columnconfigure(i, weight=1)
    
    def create_console_section(self, parent):
        """
        Create a beautiful console section.
        """
        console_frame = ttk.LabelFrame(parent, text=" üìä Results Console ", 
                                     padding="15", style='Card.TFrame')
        console_frame.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        console_frame.columnconfigure(0, weight=1)
        console_frame.rowconfigure(0, weight=1)
        
        # Create console with custom styling
        self.console = scrolledtext.ScrolledText(
            console_frame, 
            wrap=tk.WORD, 
            height=25, 
            width=90,
            font=('Consolas', 9),
            bg='#1E1E1E',           # Dark background
            fg='#FFFFFF',           # White text
            insertbackground='#FFFFFF',  # White cursor
            selectbackground='#264F78',  # Selection color
            relief='flat',
            borderwidth=1
        )
        self.console.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure text tags for colored output
        self.console.tag_configure('timestamp', foreground='#569CD6')  # Blue for timestamps
        self.console.tag_configure('success', foreground='#4EC9B0')    # Green for success
        self.console.tag_configure('error', foreground='#F44747')      # Red for errors
        self.console.tag_configure('warning', foreground='#FFCC02')    # Yellow for warnings
        self.console.tag_configure('info', foreground='#9CDCFE')       # Light blue for info
        self.console.tag_configure('missing', foreground='#F48771')    # Light red for missing
        self.console.tag_configure('extra', foreground='#B5CEA8')      # Light green for extra
        self.console.tag_configure('modified', foreground='#DCDCAA')   # Light yellow for modified
    
    def create_status_bar(self, parent):
        """
        Create a beautiful status bar.
        """
        status_frame = ttk.Frame(parent, style='Header.TFrame')
        status_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(15, 0))
        status_frame.columnconfigure(1, weight=1)
        
        # Status icon
        self.status_icon = ttk.Label(status_frame, text="‚úÖ", font=('Segoe UI', 10))
        self.status_icon.grid(row=0, column=0, padx=(0, 10))
        
        # Status text
        self.status_var = tk.StringVar()
        self.status_var.set("Ready to compare archives")
        status_label = ttk.Label(status_frame, textvariable=self.status_var, 
                               style='Subtitle.TLabel')
        status_label.grid(row=0, column=1, sticky=tk.W)
        
        # Version info
        version_label = ttk.Label(status_frame, text="v2.0", 
                                style='Subtitle.TLabel')
        version_label.grid(row=0, column=2, sticky=tk.E)
        
        # Progress bar (initially hidden)
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            status_frame,
            variable=self.progress_var,
            mode='determinate',
            length=200,
            style='Modern.Horizontal.TProgressbar'
        )
        # Initially hide the progress bar
        self.progress_bar.grid_remove()
        
        # Initialize with welcome message
        self.log_message("‚ú® Welcome to Archive Comparer v2.0!")
        self.log_message("üéØ Professional Archive Integrity Verification Tool")
        self.log_message("üìã Select your directories and click 'Compare Archives' to begin")
        self.update_status("Ready to compare archives", "‚úÖ")

    def show_progress_bar(self, maximum_value=100):
        """
        Afficher la barre de progression.
        """
        self.progress_var.set(0)
        self.progress_bar.configure(maximum=maximum_value)
        self.progress_bar.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(5, 0))
        self.root.update_idletasks()
    
    def update_progress_bar(self, value):
        """
        Mettre √† jour la barre de progression.
        """
        self.progress_var.set(value)
        self.root.update_idletasks()
    
    def hide_progress_bar(self):
        """
        Cacher la barre de progression.
        """
        self.progress_bar.grid_remove()
        self.root.update_idletasks()
    
    def create_header(self, parent):
        """
        Create a beautiful header section.
        """
        header_frame = ttk.Frame(parent, style='Header.TFrame')
        header_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        header_frame.columnconfigure(0, weight=1)
        
        # Title
        title_label = ttk.Label(header_frame, text="üóÇÔ∏è Comparateur d'Archives", style='Header.TLabel')
        title_label.grid(row=0, column=0, pady=(0, 5))
        
        # Subtitle
        subtitle_label = ttk.Label(header_frame, 
                                 text="Outil Professionnel de V√©rification d'Int√©grit√© d'Archives - APST2607",
                                 style='Subtitle.TLabel')
        subtitle_label.grid(row=1, column=0, pady=(0, 5))
        
        # Developer info
        dev_label = ttk.Label(header_frame,
                             text="D√©velopp√© par Michel Bermond - Association Pr√©vention Sant√© au Travail 2607",
                             font=('Segoe UI', 8),
                             foreground='#718096')
        dev_label.grid(row=2, column=0, pady=(0, 10))
        
        # Separator
        separator = ttk.Separator(header_frame, orient='horizontal')
        separator.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
    
    def create_input_section(self, parent):
        """
        Create a beautiful input section with cards.
        """
        input_frame = ttk.LabelFrame(parent, text=" üìÅ S√©lection des R√©pertoires ", 
                                   padding="20", style='Card.TFrame')
        input_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        input_frame.columnconfigure(1, weight=1)
        
        # Reference Path
        ref_icon = ttk.Label(input_frame, text="üìö", font=('Segoe UI', 12))
        ref_icon.grid(row=0, column=0, padx=(0, 10), pady=8, sticky=tk.W)
        
        ttk.Label(input_frame, text="R√©pertoire de R√©f√©rence:", style='Title.TLabel').grid(
            row=0, column=1, sticky=tk.W, pady=8)
        
        self.ref_path_var = tk.StringVar()
        ref_frame = ttk.Frame(input_frame)
        ref_frame.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 15))
        ref_frame.columnconfigure(0, weight=1)
        
        self.ref_path_entry = ttk.Entry(ref_frame, textvariable=self.ref_path_var, 
                                      style='Modern.TEntry', width=60)
        self.ref_path_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 10))
        
        ref_browse_btn = ttk.Button(ref_frame, text="üìÇ Parcourir", 
                                  command=self.browse_ref_path, style='Modern.TButton')
        ref_browse_btn.grid(row=0, column=1)
        
        # Extracted Path
        ext_icon = ttk.Label(input_frame, text="üì¶", font=('Segoe UI', 12))
        ext_icon.grid(row=2, column=0, padx=(0, 10), pady=8, sticky=tk.W)
        
        ttk.Label(input_frame, text="R√©pertoire Extrait:", style='Title.TLabel').grid(
            row=2, column=1, sticky=tk.W, pady=8)
        
        self.extract_path_var = tk.StringVar()
        ext_frame = ttk.Frame(input_frame)
        ext_frame.grid(row=3, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 15))
        ext_frame.columnconfigure(0, weight=1)
        
        self.extract_path_entry = ttk.Entry(ext_frame, textvariable=self.extract_path_var, 
                                          style='Modern.TEntry', width=60)
        self.extract_path_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 10))
        
        ext_browse_btn = ttk.Button(ext_frame, text="üìÇ Parcourir", 
                                  command=self.browse_extract_path, style='Modern.TButton')
        ext_browse_btn.grid(row=0, column=1)
        
        # Output File
        out_icon = ttk.Label(input_frame, text="üíæ", font=('Segoe UI', 12))
        out_icon.grid(row=4, column=0, padx=(0, 10), pady=8, sticky=tk.W)
        
        ttk.Label(input_frame, text="Exporter le Rapport vers:", style='Title.TLabel').grid(
            row=4, column=1, sticky=tk.W, pady=8)
        
        self.output_file_var = tk.StringVar()
        out_frame = ttk.Frame(input_frame)
        out_frame.grid(row=5, column=1, columnspan=2, sticky=(tk.W, tk.E))
        out_frame.columnconfigure(0, weight=1)
        
        self.output_file_entry = ttk.Entry(out_frame, textvariable=self.output_file_var, 
                                         style='Modern.TEntry', width=60)
        self.output_file_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 10))
        
        out_browse_btn = ttk.Button(out_frame, text="üíæ Enregistrer sous", 
                                  command=self.browse_output_file, style='Modern.TButton')
        out_browse_btn.grid(row=0, column=1)
    
    def log_message(self, message, tag=None):
        """
        Add a beautifully formatted message to both consoles with timestamp and colors.
        """
        import datetime
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        
        # Format the complete message
        full_message = f"[{timestamp}] {message}"
        
        # Determine message type and color (with French translations)
        if ("‚ú®" in message or "‚úÖ" in message or 
            "successfully" in message.lower() or "success" in message.lower() or
            "r√©ussi" in message.lower() or "parfaitement" in message.lower() or
            "termin√© avec succ√®s" in message.lower() or "aucun doublon" in message.lower()):
            tag = 'success'
        elif ("‚ùå" in message or 
              "error" in message.lower() or "failed" in message.lower() or
              "erreur" in message.lower() or "√©chec" in message.lower()):
            tag = 'error'
        elif ("‚ö†Ô∏è" in message or 
              "warning" in message.lower() or "attention" in message.lower() or
              "impossible" in message.lower() or "interrompue" in message.lower()):
            tag = 'warning'
        elif ("üîç" in message or "üîÑ" in message or "üìä" in message or "üîê" in message or
              "checking" in message.lower() or "scanning" in message.lower() or
              "analyse" in message.lower() or "comparaison" in message.lower() or
              "v√©rification" in message.lower() or "traitement" in message.lower() or
              "g√©n√©ration" in message.lower()):
            tag = 'info'
        elif ("MISSING" in message or "MANQUANTS" in message or "manquant" in message.lower()):
            tag = 'missing'
        elif ("EXTRA" in message or "SUPPL√âMENTAIRES" in message or "suppl√©mentaire" in message.lower()):
            tag = 'extra'
        elif ("MODIFIED" in message or "MODIFI√âS" in message or "modifi√©" in message.lower() or
              "doublons" in message.lower() or "duplicate" in message.lower()):
            tag = 'modified'
        
        # Add to main console
        self.console.insert(tk.END, f"[{timestamp}] ", 'timestamp')
        self.console.insert(tk.END, f"{message}\n", tag)
        self.console.see(tk.END)
        
        # Add to large console if it exists
        if self.large_console_text and self.large_console_window and self.large_console_window.winfo_exists():
            try:
                self.large_console_text.insert(tk.END, f"[{timestamp}] ", 'timestamp')
                self.large_console_text.insert(tk.END, f"{message}\n", tag)
                self.large_console_text.see(tk.END)
            except tk.TclError:
                # Large console window was closed
                self.large_console_window = None
                self.large_console_text = None
        
        self.root.update()
    
    def open_large_console(self):
        """
        Ouvrir une fen√™tre de console large pour g√©rer des volumes massifs de donn√©es.
        """
        if self.large_console_window and self.large_console_window.winfo_exists():
            # Amener la fen√™tre existante au premier plan
            self.large_console_window.lift()
            self.large_console_window.focus_force()
            return
        
        # Cr√©er une nouvelle fen√™tre de console large
        self.large_console_window = tk.Toplevel(self.root)
        self.large_console_window.title("üñ•Ô∏è Grande Console - Comparateur d'Archives")
        self.large_console_window.geometry("1400x800")
        self.large_console_window.minsize(1000, 600)
        
        # Configurer la fen√™tre
        self.large_console_window.configure(bg='#2D3748')
        
        # Cr√©er le cadre principal
        main_frame = ttk.Frame(self.large_console_window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Titre
        title_label = ttk.Label(main_frame, 
                               text="üñ•Ô∏è Grande Console - Optimis√©e pour l'Analyse de Gros Volumes",
                               font=('Segoe UI', 14, 'bold'),
                               foreground='#2E86AB')
        title_label.pack(pady=(0, 10))
        
        # √âtiquette d'information
        info_label = ttk.Label(main_frame,
                              text="üí° Cette console peut g√©rer efficacement 144K+ fichiers et de gros jeux de donn√©es",
                              font=('Segoe UI', 10),
                              foreground='#718096')
        info_label.pack(pady=(0, 10))
        
        # Cr√©er le cadre de la console
        console_frame = ttk.Frame(main_frame)
        console_frame.pack(fill=tk.BOTH, expand=True)
        
        # Cr√©er un grand texte avec d√©filement et param√®tres optimis√©s
        self.large_console_text = scrolledtext.ScrolledText(
            console_frame,
            wrap=tk.NONE,  # Pas de retour √† la ligne pour une meilleure performance
            height=40,
            width=120,
            font=('Consolas', 9),
            bg='#1E1E1E',
            fg='#FFFFFF',
            insertbackground='#FFFFFF',
            selectbackground='#264F78',
            relief='flat',
            borderwidth=1,
            maxundo=20,  # Limit undo operations for performance
            undo=True
        )
        self.large_console_text.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags for colored output (same as main console)
        tags = {
            'timestamp': '#569CD6',
            'success': '#4EC9B0',
            'error': '#F44747',
            'warning': '#FFCC02',
            'info': '#9CDCFE',
            'missing': '#F48771',
            'extra': '#B5CEA8',
            'modified': '#DCDCAA'
        }
        
        for tag, color in tags.items():
            self.large_console_text.tag_configure(tag, foreground=color)
        
        # Add control buttons frame
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Control buttons
        clear_btn = ttk.Button(control_frame, text="üóëÔ∏è Clear Large Console", 
                              command=self.clear_large_console, style='Modern.TButton')
        clear_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        save_btn = ttk.Button(control_frame, text="üíæ Sauvegarder Sortie Console", 
                             command=self.save_console_output, style='Modern.TButton')
        save_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        find_btn = ttk.Button(control_frame, text="üîç Rechercher dans Console", 
                             command=self.find_in_console, style='Modern.TButton')
        find_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        # Information de performance
        perf_label = ttk.Label(control_frame,
                              text="‚ö° Optimis√© pour les jeux de donn√©es de 96GB+",
                              font=('Segoe UI', 8),
                              foreground='#4EC9B0')
        perf_label.pack(side=tk.RIGHT)
        
        # Copier le contenu existant vers la grande console
        if self.console.get("1.0", tk.END).strip():
            # Copier le contenu avec le formatage appropri√©
            self._copy_console_content_with_tags()
        
        # Message de bienvenue avec couleurs
        self.large_console_text.insert(tk.END, "üñ•Ô∏è Grande console initialis√©e pour le traitement de gros volumes!\n", 'success')
        self.large_console_text.insert(tk.END, "üí™ Pr√™te √† g√©rer des jeux de donn√©es massifs (96GB+, 144K+ fichiers)\n", 'info')
        self.large_console_text.see(tk.END)
    
    def _copy_console_content_with_tags(self):
        """
        Copier le contenu de la console principale vers la grande console avec les balises de couleur appropri√©es.
        """
        try:
            # Get all content from main console
            content = self.console.get("1.0", tk.END)
            lines = content.split('\n')
            
            for line in lines:
                if not line.strip():
                    continue
                    
                # Parse timestamp and message
                if line.startswith('[') and '] ' in line:
                    timestamp_end = line.find('] ') + 2
                    timestamp = line[:timestamp_end]
                    message = line[timestamp_end:]
                    
                    # Add timestamp with color
                    self.large_console_text.insert(tk.END, timestamp, 'timestamp')
                    
                    # Determine message color (with French translations)
                    tag = None
                    if ("‚ú®" in message or "‚úÖ" in message or 
                        "successfully" in message.lower() or "success" in message.lower() or
                        "r√©ussi" in message.lower() or "parfaitement" in message.lower() or
                        "termin√© avec succ√®s" in message.lower() or "aucun doublon" in message.lower()):
                        tag = 'success'
                    elif ("‚ùå" in message or 
                          "error" in message.lower() or "failed" in message.lower() or
                          "erreur" in message.lower() or "√©chec" in message.lower()):
                        tag = 'error'
                    elif ("‚ö†Ô∏è" in message or 
                          "warning" in message.lower() or "attention" in message.lower() or
                          "impossible" in message.lower() or "interrompue" in message.lower()):
                        tag = 'warning'
                    elif ("üîç" in message or "üîÑ" in message or "üìä" in message or "üîê" in message or
                          "checking" in message.lower() or "scanning" in message.lower() or
                          "analyse" in message.lower() or "comparaison" in message.lower() or
                          "v√©rification" in message.lower() or "traitement" in message.lower() or
                          "g√©n√©ration" in message.lower()):
                        tag = 'info'
                    elif ("MISSING" in message or "MANQUANTS" in message or "manquant" in message.lower()):
                        tag = 'missing'
                    elif ("EXTRA" in message or "SUPPL√âMENTAIRES" in message or "suppl√©mentaire" in message.lower()):
                        tag = 'extra'
                    elif ("MODIFIED" in message or "MODIFI√âS" in message or "modifi√©" in message.lower() or
                          "doublons" in message.lower() or "duplicate" in message.lower()):
                        tag = 'modified'
                    
                    # Add message with color
                    self.large_console_text.insert(tk.END, message + '\n', tag)
                else:
                    # Line without timestamp
                    self.large_console_text.insert(tk.END, line + '\n')
                    
        except Exception as e:
            # If copying fails, just add the raw content
            content = self.console.get("1.0", tk.END)
            self.large_console_text.insert("1.0", content)
    
    def update_status(self, message, icon="‚úÖ"):
        """
        Update the status bar with icon and message.
        """
        self.status_icon.config(text=icon)
        self.status_var.set(message)
    
    def browse_ref_path(self):
        """
        Browse for reference directory.
        """
        path = filedialog.askdirectory(title="Select Reference Directory")
        if path:
            self.ref_path_var.set(path)
            self.log_message(f"üìö Reference path set to: {path}")
            self.update_status("Reference directory selected", "üìö")
    
    def browse_extract_path(self):
        """
        Browse for extracted directory.
        """
        path = filedialog.askdirectory(title="Select Extracted Directory")
        if path:
            self.extract_path_var.set(path)
            self.log_message(f"üì¶ Extracted path set to: {path}")
            self.update_status("Extracted directory selected", "üì¶")
    
    def browse_output_file(self):
        """
        Browse for output file location.
        """
        path = filedialog.asksaveasfilename(
            title="Save Result As",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if path:
            self.output_file_var.set(path)
            self.log_message(f"üíæ Output file set to: {path}")
            self.update_status("Export location selected", "üíæ")
    
    def clear_console(self):
        """
        Vider la console avec un bel effet d'animation.
        """
        self.console.delete(1.0, tk.END)
        self.log_message("üóëÔ∏è Console vid√©e et pr√™te pour de nouvelles op√©rations")
        self.update_status("Console vid√©e", "üóëÔ∏è")
    
    def clear_large_console(self):
        """
        Vider la grande console et ajouter un message de bienvenue color√©.
        """
        if self.large_console_text:
            self.large_console_text.delete(1.0, tk.END)
            self.large_console_text.insert(tk.END, "üóëÔ∏è Grande console vid√©e et pr√™te pour les gros volumes de donn√©es!\n", 'success')
            self.large_console_text.insert(tk.END, "üí° All colors are working properly for enhanced readability\n", 'info')
    
    def save_console_output(self):
        """
        Save the large console output to a file.
        """
        if not self.large_console_text:
            return
        
        file_path = filedialog.asksaveasfilename(
            title="üíæ Save Console Output",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("Log files", "*.log"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                content = self.large_console_text.get("1.0", tk.END)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                self.log_message(f"üíæ Console output saved to: {file_path}")
                messagebox.showinfo("‚úÖ Save Successful", f"Console output saved to:\n{file_path}")
            except Exception as e:
                self.log_message(f"‚ùå Error saving console output: {str(e)}")
                messagebox.showerror("‚ùå Save Error", str(e))
    
    def find_in_console(self):
        """
        Find text in the large console.
        """
        if not self.large_console_text:
            return
        
        search_term = tk.simpledialog.askstring("üîç Find in Console", "Enter search term:")
        if search_term:
            # Clear previous search highlights
            self.large_console_text.tag_remove('search_highlight', '1.0', tk.END)
            
            # Configure search highlight tag
            self.large_console_text.tag_configure('search_highlight', 
                                                 background='#FFFF00', 
                                                 foreground='#000000')
            
            # Find and highlight all occurrences
            start = '1.0'
            count = 0
            while True:
                pos = self.large_console_text.search(search_term, start, tk.END, nocase=True)
                if not pos:
                    break
                end = f"{pos}+{len(search_term)}c"
                self.large_console_text.tag_add('search_highlight', pos, end)
                start = end
                count += 1
            
            if count > 0:
                # Go to first occurrence
                first_pos = self.large_console_text.search(search_term, '1.0', tk.END, nocase=True)
                self.large_console_text.see(first_pos)
                messagebox.showinfo("üîç Search Results", f"Found {count} occurrences of '{search_term}'")
            else:
                messagebox.showinfo("üîç Search Results", f"'{search_term}' not found")
    
    def compare_archives_gui(self):
        """
        Effectuer la comparaison d'archives depuis les entr√©es GUI avec de belles mises √† jour de progression.
        """
        ref_path = self.ref_path_var.get().strip()
        extract_path = self.extract_path_var.get().strip()
        
        if not ref_path or not extract_path:
            messagebox.showerror("‚ùå Chemins Manquants", 
                               "Veuillez sp√©cifier les chemins de r√©f√©rence et d'extraction.")
            return
        
        if not os.path.exists(ref_path):
            messagebox.showerror("‚ùå Chemin Non Trouv√©", 
                               f"Le chemin de r√©f√©rence n'existe pas:\n{ref_path}")
            return
        
        if not os.path.exists(extract_path):
            messagebox.showerror("‚ùå Chemin Non Trouv√©", 
                               f"Le chemin d'extraction n'existe pas:\n{extract_path}")
            return
        
        try:
            # Afficher la barre de progression
            self.show_progress_bar(100)
            
            self.update_status("Comparaison des archives...", "üîÑ")
            self.log_message("üöÄ D√©marrage de la comparaison compl√®te des archives...")
            self.log_message(f"üìö R√©f√©rence: {ref_path}")
            self.log_message(f"üì¶ Extrait: {extract_path}")
            
            # Effectuer la comparaison avec progression
            self.current_report = compare_archives_with_progress(extract_path, ref_path, self.update_progress_with_bar)
            
            # Afficher de beaux r√©sultats
            self.display_comparison_results(self.current_report)
            
            # Mettre √† jour le statut bas√© sur les r√©sultats
            total_issues = (self.current_report.get('num_missing', 0) + 
                          self.current_report.get('num_extra', 0) + 
                          self.current_report.get('num_modified', 0))
            
            if total_issues == 0:
                self.update_status("‚ú® Les archives correspondent parfaitement!", "‚ú®")
            else:
                self.update_status(f"‚ö†Ô∏è Trouv√© {total_issues} diff√©rences", "‚ö†Ô∏è")
            
        except Exception as e:
            error_msg = f"‚ùå Erreur pendant la comparaison: {str(e)}"
            self.log_message(error_msg)
            messagebox.showerror("‚ùå Erreur de Comparaison", str(e))
            self.update_status("√âchec de la comparaison", "‚ùå")
        finally:
            # Cacher la barre de progression
            self.hide_progress_bar()
            messagebox.showerror("‚ùå Comparison Error", str(e))
            self.update_status("Comparison failed", "‚ùå")
    
    def update_progress(self, message):
        """
        Mettre √† jour les messages de progression pendant la comparaison avec un beau formatage.
        """
        # Ajouter des ic√¥nes appropri√©es aux messages de progression
        if "Scanning reference" in message:
            message = f"üîç {message.replace('Scanning reference', 'Analyse de r√©f√©rence')}"
        elif "Scanning extracted" in message:
            message = f"üîç {message.replace('Scanning extracted', 'Analyse extrait')}"
        elif "Comparing file lists" in message:
            message = f"üìù {message.replace('Comparing file lists', 'Comparaison des listes de fichiers')}"
        elif "Checking integrity" in message:
            message = f"üîê {message.replace('Checking integrity', 'V√©rification d\'int√©grit√©')}"
        elif "Generating final report" in message:
            message = f"üìä {message.replace('Generating final report', 'G√©n√©ration du rapport final')}"
        
        self.log_message(message)

    def update_progress_with_bar(self, message, progress_percent=None):
        """
        Mettre √† jour les messages de progression avec barre de progression pendant la comparaison.
        """
        # Ajouter des ic√¥nes appropri√©es aux messages de progression
        if "Scanning reference" in message:
            message = f"üîç {message.replace('Scanning reference', 'Analyse de r√©f√©rence')}"
            if progress_percent is None:
                progress_percent = 10
        elif "Scanning extracted" in message:
            message = f"üîç {message.replace('Scanning extracted', 'Analyse extrait')}"
            if progress_percent is None:
                progress_percent = 30
        elif "Comparing file lists" in message:
            message = f"üìù {message.replace('Comparing file lists', 'Comparaison des listes de fichiers')}"
            if progress_percent is None:
                progress_percent = 60
        elif "Checking integrity" in message:
            message = f"üîê {message.replace('Checking integrity', 'V√©rification d\'int√©grit√©')}"
            if progress_percent is None:
                progress_percent = 80
        elif "Generating final report" in message:
            message = f"üìä {message.replace('Generating final report', 'G√©n√©ration du rapport final')}"
            if progress_percent is None:
                progress_percent = 95
        
        self.log_message(message)
        
        # Mettre √† jour la barre de progression si un pourcentage est fourni
        if progress_percent is not None:
            self.update_progress_bar(progress_percent)
        self.update_status(message, "üîÑ")
    
    def display_comparison_results(self, report):
        """
        Afficher les r√©sultats de comparaison dans un arbre explorateur de fichiers magnifiquement format√©.
        """
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        self.log_message("üìä R√âSUM√â DES R√âSULTATS DE COMPARAISON", 'info')
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        
        # Affichage des statistiques magnifique
        stats = [
            ("üìÑ Fichiers manquants", report['num_missing'], 'missing'),
            ("üìÑ Fichiers suppl√©mentaires", report['num_extra'], 'extra'),
            ("üîÑ Fichiers modifi√©s", report.get('num_modified', 0), 'modified'),
            ("üìÅ Dossiers manquants", report.get('num_missing_dirs', 0), 'missing'),
            ("üìÅ Dossiers suppl√©mentaires", report.get('num_extra_dirs', 0), 'extra'),
            ("‚úÖ Fichiers identiques", report.get('num_common', 0), 'success')
        ]
        
        for label, count, tag in stats:
            self.log_message(f"{label}: {count}", tag)
        
        # For backward compatibility with old reports
        if 'missing_directories' not in report:
            enhanced_report = self._enhance_report_with_directories(report)
        else:
            enhanced_report = report
        
        # Display missing files and directories
        if enhanced_report['missing_files'] or enhanced_report.get('missing_directories', []):
            missing_tree = {}
            
            # Add missing directories
            for dir_path in enhanced_report.get('missing_directories', []):
                self._add_item_to_tree(missing_tree, dir_path, 'missing', is_directory=True)
            
            # Add missing files
            for file_path in enhanced_report['missing_files']:
                self._add_item_to_tree(missing_tree, file_path, 'missing', is_directory=False)
            
            self.log_message("\nüìã FICHIERS ET DOSSIERS MANQUANTS", 'missing')
            self.log_message("‚îÄ" * 50)
            if missing_tree:
                self._display_tree(missing_tree, "", "")
            else:
                self.log_message("  (Aucun fichier ou dossier manquant)", 'success')
        
        # Display extra files and directories
        if enhanced_report['extra_files'] or enhanced_report.get('extra_directories', []):
            extra_tree = {}
            
            # Add extra directories
            for dir_path in enhanced_report.get('extra_directories', []):
                self._add_item_to_tree(extra_tree, dir_path, 'extra', is_directory=True)
            
            # Add extra files
            for file_path in enhanced_report['extra_files']:
                self._add_item_to_tree(extra_tree, file_path, 'extra', is_directory=False)
            
            self.log_message("\nüìã FICHIERS ET DOSSIERS SUPPL√âMENTAIRES", 'extra')
            self.log_message("‚îÄ" * 50)
            if extra_tree:
                self._display_tree(extra_tree, "", "")
            else:
                self.log_message("  (Aucun fichier ou dossier suppl√©mentaire)", 'success')
        
        # Display modified files
        if enhanced_report.get('modified_files', []):
            modified_tree = {}
            
            for file_info in enhanced_report['modified_files']:
                file_path = file_info['file']
                self._add_item_to_tree(modified_tree, file_path, 'modified', is_directory=False, 
                                     extra_info=file_info)
            
            self.log_message("\nüìã FICHIERS MODIFI√âS", 'modified')
            self.log_message("‚îÄ" * 50)
            if modified_tree:
                self._display_tree(modified_tree, "", "")
            else:
                self.log_message("  (Aucun fichier modifi√©)", 'success')
        
        # Message final du r√©sultat
        if not (enhanced_report['missing_files'] or enhanced_report['extra_files'] or 
                enhanced_report.get('missing_directories', []) or enhanced_report.get('extra_directories', []) or
                enhanced_report.get('modified_files', [])):
            self.log_message("\n‚ú® CORRESPONDANCE PARFAITE! Les archives sont identiques! ‚ú®", 'success')
        else:
            total_issues = (len(enhanced_report['missing_files']) + 
                          len(enhanced_report['extra_files']) + 
                          len(enhanced_report.get('modified_files', [])))
            self.log_message(f"\n‚ö†Ô∏è Trouv√© {total_issues} diff√©rences qui n√©cessitent une attention", 'warning')
        
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        self.log_message("üìä FIN DES R√âSULTATS DE COMPARAISON", 'info')
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")
    
    def _enhance_report_with_directories(self, report):
        """
        Am√©liorer le rapport pour inclure les dossiers manquants et suppl√©mentaires.
        """
        # Obtenir tous les chemins de dossiers depuis les chemins de fichiers
        missing_dirs = set()
        extra_dirs = set()
        
        # Extraire les dossiers des fichiers manquants
        for file_path in report['missing_files']:
            parts = file_path.replace('\\', '/').split('/')
            for i in range(len(parts) - 1):  # Exclure le fichier lui-m√™me
                dir_path = '/'.join(parts[:i + 1])
                missing_dirs.add(dir_path)
        
        # Extract directories from extra files
        for file_path in report['extra_files']:
            parts = file_path.replace('\\', '/').split('/')
            for i in range(len(parts) - 1):  # Exclude the file itself
                dir_path = '/'.join(parts[:i + 1])
                extra_dirs.add(dir_path)
        
        # Remove directories that exist in both (they're not truly missing/extra)
        common_dirs = missing_dirs & extra_dirs
        missing_dirs -= common_dirs
        extra_dirs -= common_dirs
        
        # Filter out parent directories if child directories are already listed
        missing_dirs = self._filter_parent_directories(missing_dirs)
        extra_dirs = self._filter_parent_directories(extra_dirs)
        
        return {
            'missing_files': report['missing_files'],
            'extra_files': report['extra_files'],
            'missing_directories': sorted(missing_dirs),
            'extra_directories': sorted(extra_dirs),
            'num_missing': report['num_missing'],
            'num_extra': report['num_extra']
        }
    
    def _filter_parent_directories(self, directories):
        """
        Remove parent directories if their child directories are already in the set.
        """
        sorted_dirs = sorted(directories, key=lambda x: x.count('/'))
        filtered_dirs = set()
        
        for directory in sorted_dirs:
            # Check if any directory in filtered_dirs is a parent of this directory
            is_child = False
            for existing_dir in filtered_dirs:
                if directory.startswith(existing_dir + '/'):
                    is_child = True
                    break
            
            if not is_child:
                # Remove any existing directories that are children of this directory
                filtered_dirs = {d for d in filtered_dirs if not d.startswith(directory + '/')}
                filtered_dirs.add(directory)
        
        return filtered_dirs
    
    def _add_item_to_tree(self, tree, item_path, status, is_directory, extra_info=None):
        """
        Add a file or directory to the tree structure with its status.
        """
        parts = item_path.replace('\\', '/').split('/')
        current_level = tree
        
        # Navigate/create the directory structure
        for i, part in enumerate(parts):
            if part not in current_level:
                current_level[part] = {}
            
            # If this is the last part, mark its status and type
            if i == len(parts) - 1:
                current_level[part]['_status'] = status
                current_level[part]['_is_file'] = not is_directory
                current_level[part]['_is_target'] = True  # This is the actual missing/extra item
                if extra_info:
                    current_level[part]['_extra_info'] = extra_info
            else:
                # It's an intermediate directory, ensure it has the proper structure
                if '_is_file' not in current_level[part]:
                    current_level[part]['_is_file'] = False
                current_level = current_level[part]
    
    def _display_tree(self, tree, prefix, current_prefix):
        """
        Display the tree structure in file explorer format.
        """
        items = [(name, data) for name, data in tree.items() if not name.startswith('_')]
        items.sort(key=lambda x: (x[1].get('_is_file', False), x[0].lower()))
        
        for i, (name, data) in enumerate(items):
            is_last = i == len(items) - 1
            
            # Choose the appropriate tree characters
            if is_last:
                current_connector = "‚îî‚îÄ‚îÄ "
                next_prefix = current_prefix + "    "
            else:
                current_connector = "‚îú‚îÄ‚îÄ "
                next_prefix = current_prefix + "‚îÇ   "
            
            # Determine the display format based on file status
            if data.get('_is_file', False):
                # It's a file
                status = data.get('_status', '')
                is_target = data.get('_is_target', False)
                extra_info = data.get('_extra_info', {})
                
                if is_target:
                    if status == 'missing':
                        display_name = f"‚ùå {name} (MISSING FILE)"
                    elif status == 'extra':
                        display_name = f"‚ûï {name} (EXTRA FILE)"
                    elif status == 'modified':
                        size_ref = extra_info.get('size_ref', 0)
                        size_ext = extra_info.get('size_ext', 0)
                        display_name = f"üîÑ {name} (MODIFIED - Ref:{size_ref}B, Ext:{size_ext}B)"
                    else:
                        display_name = f"üìÑ {name}"
                else:
                    display_name = f"üìÑ {name}"
            else:
                # It's a directory
                status = data.get('_status', '')
                is_target = data.get('_is_target', False)
                
                if is_target:
                    if status == 'missing':
                        display_name = f"‚ùå {name}/ (MISSING DIRECTORY)"
                    elif status == 'extra':
                        display_name = f"‚ûï {name}/ (EXTRA DIRECTORY)"
                    else:
                        display_name = f"üìÅ {name}/"
                else:
                    display_name = f"üìÅ {name}/"
            
            self.log_message(f"{current_prefix}{current_connector}{display_name}")
            
            # Show additional details for modified files
            if data.get('_status') == 'modified' and data.get('_extra_info'):
                info = data.get('_extra_info', {})
                if 'hash_ref' in info and 'hash_ext' in info:
                    self.log_message(f"{current_prefix}{'    ' if is_last else '‚îÇ   '}    Ref hash: {info['hash_ref'][:16]}...")
                    self.log_message(f"{current_prefix}{'    ' if is_last else '‚îÇ   '}    Ext hash: {info['hash_ext'][:16]}...")
            
            # Recursively display subdirectories/files
            if not data.get('_is_file', False):
                self._display_tree(data, next_prefix, next_prefix)
    
    def export_result(self):
        """
        Exporter le r√©sultat de comparaison vers un fichier avec de beaux commentaires.
        """
        if self.current_report is None:
            messagebox.showwarning("‚ö†Ô∏è Aucun R√©sultat", 
                                 "Aucun r√©sultat de comparaison √† exporter.\nVeuillez d'abord effectuer une comparaison.")
            return
        
        output_path = self.output_file_var.get().strip()
        if not output_path:
            output_path = filedialog.asksaveasfilename(
                title="üì§ Exporter les R√©sultats Sous",
                defaultextension=".json",
                filetypes=[("Fichiers JSON", "*.json"), ("Tous les fichiers", "*.*")]
            )
        
        if output_path:
            try:
                self.update_status("Export des r√©sultats...", "üì§")
                
                # Ajouter de belles m√©tadonn√©es √† l'export
                export_data = {
                    "metadata": {
                        "timestamp": str(datetime.datetime.now()),
                        "reference_path": self.ref_path_var.get(),
                        "extracted_path": self.extract_path_var.get(),
                        "application": "Comparateur d'Archives v2.0 - APST2607",
                        "total_differences": (self.current_report.get('num_missing', 0) + 
                                            self.current_report.get('num_extra', 0) + 
                                            self.current_report.get('num_modified', 0))
                    },
                    "results": self.current_report
                }
                
                with open(output_path, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)
                
                self.log_message(f"üì§ R√©sultats export√©s avec succ√®s vers: {output_path}")
                self.update_status("Export termin√© avec succ√®s", "‚úÖ")
                messagebox.showinfo("‚úÖ Export R√©ussi", 
                                  f"R√©sultats export√©s avec succ√®s vers:\n{output_path}")
                
            except Exception as e:
                error_msg = f"‚ùå Erreur lors de l'export: {str(e)}"
                self.log_message(error_msg)
                messagebox.showerror("‚ùå Erreur d'Export", str(e))
                self.update_status("√âchec de l'export", "‚ùå")
    
    def import_result(self):
        """
        Importer et afficher des r√©sultats de comparaison pr√©c√©demment sauvegard√©s avec de beaux commentaires.
        """
        file_path = filedialog.askopenfilename(
            title="üì• Importer les R√©sultats",
            filetypes=[("Fichiers JSON", "*.json"), ("Tous les fichiers", "*.*")]
        )
        
        if file_path:
            try:
                self.update_status("Importing results...", "üì•")
                
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # G√©rer l'ancien format (r√©sultats directs) et le nouveau format (avec m√©tadonn√©es)
                if 'results' in data:
                    report = data['results']
                    metadata = data.get('metadata', {})
                    
                    self.log_message(f"üì• R√©sultats import√©s avec succ√®s depuis: {file_path}")
                    if 'timestamp' in metadata:
                        self.log_message(f"üïí Horodatage de comparaison original: {metadata['timestamp']}")
                    if 'reference_path' in metadata:
                        self.log_message(f"üìö Chemin de r√©f√©rence original: {metadata['reference_path']}")
                    if 'extracted_path' in metadata:
                        self.log_message(f"üì¶ Chemin d'extraction original: {metadata['extracted_path']}")
                    if 'total_differences' in metadata:
                        self.log_message(f"üìä Total des diff√©rences trouv√©es: {metadata['total_differences']}")
                else:
                    # Ancien format - r√©sultats directs
                    report = data
                    self.log_message(f"üì• R√©sultats legacy import√©s depuis: {file_path}")
                
                # Valider les donn√©es import√©es
                required_keys = ['missing_files', 'extra_files', 'num_missing', 'num_extra']
                if all(key in report for key in required_keys):
                    self.current_report = report
                    self.display_comparison_results(report)
                    self.update_status("Import termin√© avec succ√®s", "‚úÖ")
                else:
                    raise ValueError("Format de fichier invalide - champs requis manquants")
                    
            except Exception as e:
                error_msg = f"‚ùå Erreur lors de l'import: {str(e)}"
                self.log_message(error_msg)
                messagebox.showerror("‚ùå Erreur d'Import", str(e))
                self.update_status("√âchec de l'import", "‚ùå")

    def detect_duplicates(self):
        """
        D√©tecter les fichiers en double dans un r√©pertoire en utilisant des hachages SHA-256.
        """
        # Demander √† l'utilisateur de s√©lectionner un r√©pertoire
        directory = filedialog.askdirectory(
            title="üîç S√©lectionner le R√©pertoire pour D√©tecter les Doublons",
        )
        
        if not directory:
            return
        
        if not os.path.exists(directory):
            messagebox.showerror("‚ùå Erreur", f"Le r√©pertoire n'existe pas: {directory}")
            return
        
        try:
            # Afficher la barre de progression
            self.show_progress_bar(100)
            
            self.update_status("D√©tection des doublons en cours...", "üîç")
            self.log_message("üöÄ D√©marrage de la d√©tection des fichiers en double...")
            self.log_message(f"üìÅ R√©pertoire analys√©: {directory}")
            self.log_message("üîß Filtres appliqu√©s: fichiers entre 1KB et 2GB, exclusion des fichiers syst√®me", 'info')
            
            # Effectuer la d√©tection des doublons
            duplicates_report = self._scan_for_duplicates(directory)
            
            # Afficher les r√©sultats
            self.display_duplicates_results(duplicates_report)
            
            # Mettre √† jour le statut
            total_duplicates = sum(len(group) for group in duplicates_report['duplicate_groups'].values())
            if total_duplicates == 0:
                self.update_status("‚ú® Aucun doublon trouv√©!", "‚ú®")
            else:
                self.update_status(f"‚ö†Ô∏è Trouv√© {len(duplicates_report['duplicate_groups'])} groupes de doublons", "‚ö†Ô∏è")
                
        except KeyboardInterrupt:
            self.log_message("‚ö†Ô∏è Op√©ration interrompue par l'utilisateur", 'warning')
            self.update_status("Op√©ration annul√©e", "‚ö†Ô∏è")
        except Exception as e:
            error_msg = f"‚ùå Erreur lors de la d√©tection des doublons: {str(e)}"
            self.log_message(error_msg)
            messagebox.showerror("‚ùå Erreur de D√©tection", str(e))
            self.update_status("√âchec de la d√©tection", "‚ùå")
        finally:
            # Cacher la barre de progression
            self.hide_progress_bar()

    def _scan_for_duplicates(self, directory):
        """
        Scanner le r√©pertoire pour identifier les fichiers en double avec optimisations pour gros volumes.
        """
        file_hashes = {}  # hash -> [list of file paths]
        total_files = 0
        processed_files = 0
        skipped_files = 0
        error_files = 0
        
        # Compter le nombre total de fichiers avec filtrage
        self.log_message("üîç Comptage des fichiers √† analyser...")
        for root, dirs, files in os.walk(directory):
            # Ignorer les dossiers syst√®me et cach√©s
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['System Volume Information', '$RECYCLE.BIN', 'hiberfil.sys', 'pagefile.sys']]
            
            for file in files:
                # Ignorer les fichiers syst√®me, temporaires et tr√®s petits
                if not file.startswith('.') and not file.lower().endswith(('.tmp', '.temp', '.log')):
                    file_path = os.path.join(root, file)
                    try:
                        # Ignorer les fichiers tr√®s petits (< 1KB) et tr√®s gros (> 2GB pour √©viter la saturation m√©moire)
                        file_size = os.path.getsize(file_path)
                        if 1024 <= file_size <= 2 * 1024 * 1024 * 1024:  # Entre 1KB et 2GB
                            total_files += 1
                        else:
                            skipped_files += 1
                    except (OSError, PermissionError):
                        skipped_files += 1
        
        if skipped_files > 0:
            self.log_message(f"‚ö†Ô∏è {skipped_files} fichiers ignor√©s (syst√®me, trop petits/gros, ou inaccessibles)", 'warning')
        
        self.log_message(f"üìä Analyse de {total_files} fichiers pour d√©tecter les doublons...")
        
        if total_files == 0:
            self.log_message("‚ö†Ô∏è Aucun fichier valide √† analyser", 'warning')
            return {
                'total_files': 0,
                'unique_files': 0,
                'duplicate_groups': {},
                'total_duplicate_files': 0
            }
        
        # Initialiser la barre de progression
        self.update_progress_bar(0)
        
        # Scanner tous les fichiers et calculer leurs hachages avec gestion d'erreurs robuste
        for root, dirs, files in os.walk(directory):
            # Ignorer les dossiers syst√®me et cach√©s
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['System Volume Information', '$RECYCLE.BIN', 'hiberfil.sys', 'pagefile.sys']]
            
            for file in files:
                if not file.startswith('.') and not file.lower().endswith(('.tmp', '.temp', '.log')):
                    file_path = os.path.join(root, file)
                    try:
                        # V√©rifier la taille du fichier
                        file_size = os.path.getsize(file_path)
                        if not (1024 <= file_size <= 2 * 1024 * 1024 * 1024):
                            continue
                        
                        # Calculer le hachage SHA-256 avec gestion d'erreurs
                        file_hash = self._calculate_file_hash_safe(file_path)
                        
                        if file_hash:  # Seulement si le hachage a r√©ussi
                            if file_hash not in file_hashes:
                                file_hashes[file_hash] = []
                            file_hashes[file_hash].append(file_path)
                        else:
                            error_files += 1
                        
                        processed_files += 1
                        
                        # Mise √† jour de progression avec lib√©ration p√©riodique de m√©moire
                        progress_percent = min(int((processed_files / total_files) * 90), 90)
                        self.update_progress_bar(progress_percent)
                        
                        # Mise √† jour de progression et nettoyage m√©moire tous les 100 fichiers
                        if processed_files % 100 == 0:
                            progress_msg = f"Traitement: {processed_files}/{total_files} fichiers"
                            if error_files > 0:
                                progress_msg += f" ({error_files} erreurs)"
                            self.log_message(f"üîÑ {progress_msg}")
                            self.root.update_idletasks()
                            
                            # Forcer le garbage collection pour lib√©rer la m√©moire
                            import gc
                            gc.collect()
                        
                        # Pause p√©riodique pour √©viter de bloquer l'interface
                        if processed_files % 50 == 0:
                            self.root.update()
                            
                    except (OSError, PermissionError, FileNotFoundError) as e:
                        error_files += 1
                        if error_files <= 10:  # Limiter les messages d'erreur
                            self.log_message(f"‚ö†Ô∏è Acc√®s refus√©: {os.path.basename(file_path)}", 'warning')
                        elif error_files == 11:
                            self.log_message("‚ö†Ô∏è Plus de 10 erreurs d'acc√®s, les suivantes seront compt√©es silencieusement", 'warning')
                    except KeyboardInterrupt:
                        self.log_message("‚ö†Ô∏è Op√©ration interrompue par l'utilisateur", 'warning')
                        raise
                    except Exception as e:
                        error_files += 1
                        if error_files <= 5:  # Limiter les messages d'erreur d√©taill√©s
                            self.log_message(f"‚ö†Ô∏è Erreur inattendue pour {os.path.basename(file_path)}: {str(e)[:100]}", 'warning')
        
        # Phase finale : identification des doublons (10% restants)
        self.update_progress_bar(90)
        self.log_message("üîÑ Identification des groupes de doublons...")
        
        # Identifier les doublons (hachages avec plus d'un fichier)
        duplicate_groups = {}
        unique_files = 0
        
        for file_hash, file_paths in file_hashes.items():
            if len(file_paths) > 1:
                # Cr√©er un nom de groupe bas√© sur le premier fichier
                group_name = os.path.basename(file_paths[0])
                duplicate_groups[group_name] = file_paths
            else:
                unique_files += 1
        
        # Finaliser la barre de progression
        self.update_progress_bar(100)
        
        if error_files > 0:
            self.log_message(f"‚ö†Ô∏è Total: {error_files} fichiers non trait√©s √† cause d'erreurs", 'warning')
        
        return {
            'total_files': processed_files,
            'unique_files': unique_files,
            'duplicate_groups': duplicate_groups,
            'total_duplicate_files': sum(len(group) for group in duplicate_groups.values()),
            'error_files': error_files,
            'skipped_files': skipped_files
        }

    def _calculate_file_hash(self, file_path):
        """
        Calculer le hachage SHA-256 d'un fichier.
        """
        hash_sha256 = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                # Lire le fichier par blocs pour √©conomiser la m√©moire
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_sha256.update(chunk)
        except Exception as e:
            raise Exception(f"Erreur lors du calcul du hachage pour {file_path}: {str(e)}")
        return hash_sha256.hexdigest()

    def _calculate_file_hash_safe(self, file_path):
        """
        Calculer le hachage SHA-256 d'un fichier avec gestion d'erreurs robuste pour gros volumes.
        """
        hash_sha256 = hashlib.sha256()
        try:
            # V√©rifier l'acc√®s au fichier avant de l'ouvrir
            if not os.access(file_path, os.R_OK):
                return None
            
            # V√©rifier que le fichier n'est pas un lien symbolique bris√©
            if os.path.islink(file_path) and not os.path.exists(file_path):
                return None
            
            with open(file_path, "rb") as f:
                # Lire le fichier par blocs plus petits pour les gros fichiers
                chunk_size = 8192  # 8KB chunks
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    hash_sha256.update(chunk)
                    
                    # Permettre l'interruption pour les tr√®s gros fichiers
                    self.root.update_idletasks()
            
            return hash_sha256.hexdigest()
            
        except (PermissionError, OSError, FileNotFoundError):
            # Fichier inaccessible, verrouill√© ou supprim√© pendant le traitement
            return None
        except MemoryError:
            # Fichier trop gros pour la m√©moire disponible
            self.log_message(f"‚ö†Ô∏è Fichier trop volumineux pour la m√©moire: {os.path.basename(file_path)}", 'warning')
            return None
        except KeyboardInterrupt:
            # Permettre l'interruption utilisateur
            raise
        except Exception as e:
            # Toute autre erreur inattendue
            return None

    def display_duplicates_results(self, report):
        """
        Afficher les r√©sultats de d√©tection des doublons dans un format d'arbre magnifiquement format√©.
        """
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        self.log_message("üîç R√âSULTATS DE D√âTECTION DES DOUBLONS", 'info')
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        
        # Statistiques magnifiques
        stats = [
            ("üìÑ Fichiers analys√©s", report['total_files'], 'info'),
            ("‚úÖ Fichiers uniques", report['unique_files'], 'success'),
            ("üîÑ Groupes de doublons", len(report['duplicate_groups']), 'modified'),
            ("üìÑ Total fichiers en double", report['total_duplicate_files'], 'missing')
        ]
        
        # Ajouter les statistiques d'erreurs si pr√©sentes
        if report.get('error_files', 0) > 0:
            stats.append(("‚ö†Ô∏è Fichiers avec erreurs", report['error_files'], 'warning'))
        if report.get('skipped_files', 0) > 0:
            stats.append(("‚è© Fichiers ignor√©s", report['skipped_files'], 'warning'))
        
        for label, count, tag in stats:
            self.log_message(f"{label}: {count}", tag)
        
        # Afficher les groupes de doublons
        if report['duplicate_groups']:
            self.log_message("\nüìã FICHIERS EN DOUBLE D√âTECT√âS", 'missing')
            self.log_message("‚îÄ" * 50)
            
            for group_name, file_paths in report['duplicate_groups'].items():
                self.log_message(f"\nüîÑ Groupe: {group_name} ({len(file_paths)} copies)", 'modified')
                for i, file_path in enumerate(file_paths, 1):
                    # Afficher le chemin de fa√ßon s√©curis√©e pour tous les disques
                    display_path = self._get_display_path(file_path)
                    self.log_message(f"  {i}. {display_path}", 'warning')
        else:
            self.log_message("\n‚ú® AUCUN DOUBLON D√âTECT√â! Tous les fichiers sont uniques! ‚ú®", 'success')
        
        # Calcul de l'espace potentiellement √©conomisable
        if report['duplicate_groups']:
            total_wasted_space = 0
            for file_paths in report['duplicate_groups'].values():
                if file_paths:
                    try:
                        file_size = os.path.getsize(file_paths[0])
                        # Espace gaspill√© = taille du fichier * (nombre de copies - 1)
                        total_wasted_space += file_size * (len(file_paths) - 1)
                    except:
                        pass
            
            if total_wasted_space > 0:
                # Convertir en unit√©s lisibles
                if total_wasted_space < 1024:
                    size_str = f"{total_wasted_space} bytes"
                elif total_wasted_space < 1024 * 1024:
                    size_str = f"{total_wasted_space / 1024:.2f} KB"
                elif total_wasted_space < 1024 * 1024 * 1024:
                    size_str = f"{total_wasted_space / (1024 * 1024):.2f} MB"
                else:
                    size_str = f"{total_wasted_space / (1024 * 1024 * 1024):.2f} GB"
                
                self.log_message(f"\nüíæ Espace potentiellement √©conomisable: {size_str}", 'info')
        
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        self.log_message("üîç FIN DE LA D√âTECTION DES DOUBLONS", 'info')
        self.log_message("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

    def _get_display_path(self, file_path, base_directory=None):
        """
        Obtenir un chemin d'affichage lisible, g√©rant les disques diff√©rents sur Windows.
        """
        try:
            if base_directory:
                # Essayer d'obtenir le chemin relatif par rapport au r√©pertoire de base
                relative_path = os.path.relpath(file_path, base_directory)
                # Si le chemin relatif commence par '..\\..\\..' c'est probablement sur un autre disque
                if not relative_path.startswith('..\\..\\..'):
                    return relative_path
            else:
                # Essayer d'obtenir le chemin relatif par rapport au r√©pertoire courant
                relative_path = os.path.relpath(file_path)
                # Si le chemin relatif ne commence pas par de multiples '..' c'est OK
                if not relative_path.startswith('..\\..\\..'):
                    return relative_path
        except ValueError:
            # ValueError est lev√©e quand les chemins sont sur des disques diff√©rents
            pass
        
        # Si on ne peut pas faire de chemin relatif, afficher juste le nom du fichier et son dossier parent
        try:
            parent_dir = os.path.basename(os.path.dirname(file_path))
            file_name = os.path.basename(file_path)
            drive = os.path.splitdrive(file_path)[0]
            if parent_dir:
                return f"{drive}\\...\\{parent_dir}\\{file_name}"
            else:
                return f"{drive}\\{file_name}"
        except:
            # En dernier recours, afficher le chemin complet
            return file_path


#### functions
def main():
    """ 
        main function - launches GUI
    """
    root = tk.Tk()
    app = ArchiveComparerGUI(root)
    root.mainloop()

def compare_archives_with_progress(extracted_path, reference_path, progress_callback=None):
    """
        Compare the contents of an archive with a reference directory with progress updates.
        
        Parameters:
        - extracted_path: Path to the extracted archive directory.
        - reference_path: Path to the reference directory.
        - progress_callback: Function to call for progress updates.
        
        Returns:
        - A report of missing, extra, and modified files along with directories.
    """
    def update_progress(message):
        if progress_callback:
            progress_callback(message)
    
    # Get the list of files and directories in the extracted archive and reference directory
    update_progress("Scanning reference directory...")
    reference_files = get_file_list(reference_path)
    reference_dirs = get_directory_list(reference_path)
    
    update_progress("Scanning extracted directory...")
    extracted_files = get_file_list(extracted_path)
    extracted_dirs = get_directory_list(extracted_path)

    # Compare the file lists
    update_progress("Comparing file lists...")
    missing_files = reference_files - extracted_files
    extra_files = extracted_files - reference_files
    common_files = reference_files & extracted_files
    
    # Compare the directory lists
    missing_dirs = reference_dirs - extracted_dirs
    extra_dirs = extracted_dirs - reference_dirs
    
    # Check integrity of common files
    update_progress(f"üîê Checking integrity of {len(common_files)} common files...")
    modified_files = []
    
    # Batch progress updates for better performance with large datasets
    batch_size = max(1, len(common_files) // 100)  # Update progress every 1% of files
    if batch_size < 50:
        batch_size = 50  # Minimum batch size for performance
    
    for i, file_path in enumerate(common_files):
        if i % batch_size == 0:  # Update progress in batches
            progress_pct = int((i / len(common_files)) * 100)
            update_progress(f"üîê Checking file integrity... {i + 1:,}/{len(common_files):,} ({progress_pct}%)")
        
        ref_file_path = os.path.join(reference_path, file_path.replace('/', os.sep))
        ext_file_path = os.path.join(extracted_path, file_path.replace('/', os.sep))
        
        try:
            ref_hash = calculate_file_hash(ref_file_path)
            ext_hash = calculate_file_hash(ext_file_path)
            
            if ref_hash != ext_hash:
                # Files are different
                ref_size = os.path.getsize(ref_file_path)
                ext_size = os.path.getsize(ext_file_path)
                
                modified_files.append({
                    'file': file_path,
                    'hash_ref': ref_hash,
                    'hash_ext': ext_hash,
                    'size_ref': ref_size,
                    'size_ext': ext_size
                })
        except (OSError, IOError) as e:
            # Handle file access errors
            modified_files.append({
                'file': file_path,
                'error': str(e),
                'hash_ref': 'ERROR',
                'hash_ext': 'ERROR',
                'size_ref': 0,
                'size_ext': 0
            })
    
    update_progress("Generating final report...")
    
    # Generate report
    report = {
        "missing_files": list(missing_files),
        "extra_files": list(extra_files),
        "modified_files": modified_files,
        "missing_directories": list(missing_dirs),
        "extra_directories": list(extra_dirs),
        "num_missing": len(missing_files),
        "num_extra": len(extra_files),
        "num_modified": len(modified_files),
        "num_missing_dirs": len(missing_dirs),
        "num_extra_dirs": len(extra_dirs),
        "num_common": len(common_files) - len(modified_files)  # Files that are identical
    }
    
    return report

def compare_archives(extracted_path, reference_path):
    """
        Compare the contents of an archive with a reference directory.
        
        Parameters:
        - extracted_path: Path to the extracted archive directory.
        - reference_path: Path to the reference directory.

        Returns:
        - A report of missing, extra, and modified files along with directories.
    """
    return compare_archives_with_progress(extracted_path, reference_path)

def calculate_file_hash(file_path, hash_algorithm='sha256'):
    """
        Calculate the hash of a file.
        
        Parameters:
        - file_path: Path to the file.
        - hash_algorithm: Hash algorithm to use (default: sha256).
        
        Returns:
        - The hexadecimal hash string of the file.
    """
    hash_obj = hashlib.new(hash_algorithm)
    
    try:
        with open(file_path, 'rb') as f:
            # Read file in chunks to handle large files efficiently
            for chunk in iter(lambda: f.read(8192), b""):
                hash_obj.update(chunk)
    except (OSError, IOError):
        # Return a special hash for files that can't be read
        return "ERROR_READING_FILE"
    
    return hash_obj.hexdigest()

def get_directory_list(directory):
    """
        Get a set of all directory paths in the given directory and its subdirectories.
        
        Parameters:
        - directory: Path to the directory.

        Returns:
        - A set of directory paths relative to the given directory.
    """
    dir_set = set()
    for root, dirs, _ in os.walk(directory):
        for dir_name in dirs:
            try:
                relative_path = os.path.relpath(os.path.join(root, dir_name), directory)
                # Normalize path separators
                relative_path = relative_path.replace('\\', '/')
                dir_set.add(relative_path)
            except ValueError:
                # Handle different drives on Windows
                full_path = os.path.join(root, dir_name)
                # Use path relative to the directory's drive
                try:
                    # Remove the directory prefix manually if on same drive
                    if full_path.startswith(directory):
                        relative_path = full_path[len(directory):].lstrip('\\/')
                        relative_path = relative_path.replace('\\', '/')
                        dir_set.add(relative_path)
                except:
                    # If all else fails, use basename
                    dir_set.add(os.path.basename(full_path))
    return dir_set

def get_file_list(directory):
    """
        Get a set of all file paths in the given directory and its subdirectories.
        
        Parameters:
        - directory: Path to the directory.

        Returns:
        - A set of file paths relative to the given directory.
    """
    file_set = set()
    for root, _, files in os.walk(directory):
        for file in files:
            try:
                relative_path = os.path.relpath(os.path.join(root, file), directory)
                # Normalize path separators
                relative_path = relative_path.replace('\\', '/')
                file_set.add(relative_path)
            except ValueError:
                # Handle different drives on Windows
                full_path = os.path.join(root, file)
                # Use path relative to the directory's drive
                try:
                    # Remove the directory prefix manually if on same drive
                    if full_path.startswith(directory):
                        relative_path = full_path[len(directory):].lstrip('\\/')
                        relative_path = relative_path.replace('\\', '/')
                        file_set.add(relative_path)
                except:
                    # If all else fails, use basename
                    file_set.add(os.path.basename(full_path))
    return file_set

#### main

if __name__ == "__main__":
    main()